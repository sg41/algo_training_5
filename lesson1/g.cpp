/*
Вы играете в интересную стратегию. У вашего соперника остались
всего одна казарма — здание, в котором постоянно появляются новые
солдаты. Перед атакой у вас есть x солдат. За один раунд каждый
солдат может убить одного из солдат противника или нанести 1 очко
урона казарме (вычесть единицу здоровья у казармы). Изначально у
вашего оппонента нет солдат. Тем не менее, его казарма имеет y
единиц здоровья и производит p солдат за раунд.

Ход одного раунда:

    Каждый солдат из вашей армии либо убивает одного из солдат
    вашего противника, либо наносит 1 очко урона казарме. Каждый
    солдат может выбрать своё действие. Когда казарма теряет все
    свои единицы здоровья, она разрушается.

    Ваш противник атакует. Он убьет k ваших солдат, где k —
    количество оставшихся у противника солдат.

    Если казармы еще не разрушены, ваш противник производит p
    новых солдат.

Ваша задача — разрушить казарму и убить всех солдат противника.
Если это возможно, посчитайте минимальное количество раундов,
которое вам нужно для этого. В противном случае выведите -1.

Формат ввода
На вход подаётся три целых числа x, y, p (1 ≤ x, y, p ≤ 5000) —
количество ваших солдат на старте игры, количество очков здоровья
казармы и количество производимых за раунд казармой солдат,
соответственно. Каждое число расположено в новой строке.

Формат вывода
Если возможно убить всех вражеских солдат и разрушить казарму,
выведите минимальное количество раундов, необходимых для этого.
В противном случае выведите -1.

Пример 1
Ввод
10
11
15

Вывод
4

Пример 2
Ввод
1
2
1

Вывод
-1

Пример 3
Ввод
1
1
1

Вывод
1

Пример 4
Ввод
25
200
10

Вывод
13

Примечания
В первом примере в первом раунде сначала все ваши солдату атакуют
казарму, после этого не происходит ничего, потому что у врага нет
солдат, затем у врага появляется 15 солдат. Во втором раунде один
ваш солдат добивает казарму, остальные 9 солдат убивают 9 солдат
врага. Оставшиеся 6 солдат врага убивают 6 ваших солдат, но армия
врага не пополняется, поскольку казарма разрушена. В третьем раунде
сначала вы убиваете четверых солдат врага, затем враг двоих ваших
солдат. В последнем, четвертом, раунде вы добиваете двух оставшихся
солдат врага.
*/
#include <algorithm>
#include <cmath>
#include <iostream>
#include <vector>
int decrease_or_zero(int a, int b) { return a - b >= 0 ? a - b : 0; };
int count_moves(int x, int y, int p, double delay) {
  int e = 0, r = 0;
  int prev_x = x, prev_y = y, prev_e = e;
  for (; x > 0 && (y > 0 || e > 0); r++) {
    if (e <= x) {
      int reminder = x - y;
      double k = ((1.0 + std::sqrt(5.)) / 2.) * (e - reminder) + delay;
      if (y <= x && x >= k) {
        y = 0;
        e = decrease_or_zero(e, reminder);
      } else {
        reminder = x - e;
        e = 0;
        y = decrease_or_zero(y, reminder);
      }
    } else {
      if (y <= x) {
        int remider = x - y;
        y = 0;
        e = decrease_or_zero(e, remider);
      } else {
        e = decrease_or_zero(e, x);
      }
    }
    x = decrease_or_zero(x, e);
    if (y > 0) {
      e += p;
    }
    if (prev_e == e && prev_x == x && prev_y == y) {
      x = -1;
      break;
    } else {
      prev_e = e;
      prev_x = x;
      prev_y = y;
    }
  }
  return x <= 0 ? -1 : r;
}
int main(void) {
  int x, y, p;
  std::cin >> x >> y >> p;

  std::vector<int> res;
  res.push_back(count_moves(x, y, p, 0));
  res.push_back(count_moves(x, y, p, 1));
  for (int i = 0; i < 40; i++) {
    res.push_back(count_moves(x, y, p, x * 0.025 * i));
  }
  std::sort(res.begin(), res.end());

  int result = -1;
  for (auto r : res) {
    if (r > 0) {
      result = r;
      break;
    }
  }

  std::cout << result << std::endl;

  return 0;
}